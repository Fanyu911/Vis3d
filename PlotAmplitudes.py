#!/usr/local/bin/python3.7

"""
This script plots amplitude field slices, using data generated by Ultraino simulations.

Euan Freeman (University of Glasgow)
Alexander Ng (University of Glasgow)
"""

import sys
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import griddata
import mpld3

def plot_slice(filename, fixed_axis, axis_value, levels=130, amp_min=0, amp_max=2500, save=False, file_prefix="", show=True, xmin=None, xmax=None, ymin=None, ymax=None):
    """
    This function plots a 2D slice at the specified `fixed_axis` value.
    
    Args:
        filename:    File path containing the amplitude data.
        fixed_axis:  Specifies the fixed axis for the slice (x, y or z).
        axis_value:  Create a slice from this position along `fixed_axis`.
        levels:      Number of levels in the colour map.
        amp_min:     Minimum amplitude for the colour scale.
        amp_max:     Maximum amplitude for the colour scale.
        save:        If True, save image as a file.
        file_prefix: Prefix for output image filename.
        show:        If True, show image on screen.
        xmin:        Minimum x-axis value.
        xmax:        Maximum x-axis value.
        ymin:        Minimum y-axis value.
        ymax:        Maximum y-axis value.
    """

    # Check fixed_axis has a valid value
    if fixed_axis not in ["x", "y", "z", "X", "Y", "Z"]:
        print("Error: Fixed axis must be x, y or z.")
        exit(0)
    
    # Read from the file. Expected format: `X,Y,Z,Amplitude`
    _x,_y,_z,_amplitude = np.loadtxt(filename, delimiter=",").T
    
    # Count the number of measurements we have for the given fixed_axis value
    if fixed_axis in ["x", "X"]:
        n = np.count_nonzero(_x == axis_value)
    elif fixed_axis in ["y", "Y"]:
        n = np.count_nonzero(_y == axis_value)
    else:
        n = np.count_nonzero(_z == axis_value)
    
    # Check if we have any measurements
    if n <= 0:
        print("Error: The " + fixed_axis + " axis has no measurements at " + str(axis_value) + "m.")
        exit(0)
    
    # Take the other values for the given fixed axis value
    x_axis = []
    y_axis = []
    amplitude = []
    
    # Update our internal representation of the data
    for i in range(len(_amplitude)):
        if fixed_axis in ["x", "X"]:
            if _x[i] == axis_value:
                x_axis += [_z[i]]
                y_axis += [_y[i]]
                amplitude += [_amplitude[i]]
        elif fixed_axis in ["y", "Y"]:
            if _y[i] == axis_value:
                x_axis += [_x[i]]
                y_axis += [_z[i]]
                amplitude += [_amplitude[i]]
        else:
            if _z[i] == axis_value:
                x_axis += [_x[i]]
                y_axis += [_y[i]]
                amplitude += [_amplitude[i]]
    
    # Convert from Python arrays to Numpy arrays
    x = np.array(x_axis)
    y = np.array(y_axis)
    amplitude = np.array(amplitude)
    
    # Create a linear space for interpolating between x and z axes values
    xi = np.linspace(x.min() if xmin == None else xmin, x.max() if xmax == None else xmax, 1000)
    yi = np.linspace(y.min() if ymin == None else ymin, y.max() if ymax == None else ymax, 1000)
    
    # Interpolate the x and z axes to fill in the gaps between measurements
    amplitudei = griddata((x, y), amplitude, (xi[None,:], yi[:,None]), method='cubic')
    
    # Plot the interpolated data as a contour map
    if fixed_axis in ["x", "X"]:
        xlab = "z (m)"
        ylab = "y (m)"
    elif fixed_axis in ["y", "Y"]:
        xlab = "x (m)"
        ylab = "z (m)"
    else:
        xlab = "x (m)"
        ylab = "y (m)"
    
    # Generate plot title
    title = filename.split("/")[-1] + "-" + fixed_axis + "=" + str(axis_value) + "m"
    
    # Create new plot figure
    fig, ax = plt.subplots(nrows=1, ncols=1)
    
    # Create a contour plot
    cs = ax.contourf(xi, yi, amplitudei, levels=levels,
                     cmap=plt.cm.magma, vmin=amp_min, vmax=amp_max)
    ax.invert_xaxis()
    ax.axis('scaled')
    ax.set_facecolor((0.0, 0.0, 0.0))
    ax.set_title(title, pad=20)
    ax.set_xlabel(xlab)
    ax.set_ylabel(ylab)
    
    # Set maximum value as 30cm (0.3m)
    if fixed_axis in ["x", "X", "z", "z"]:
        ax.set_ylim(0, 0.3)
    
    # Create colour bar scale for the colour map
    cbar = fig.colorbar(cs)
    cbar.ax.set_ylabel("Amplitude (Pa)")
    cbar.ax.set_yticklabels(['< 0', '500', '1000', '1500', '2000', '2500'])

    if save:
        plt.savefig(file_prefix+title+".png", bbox_inches='tight',
                    dpi=300, quality=100)
    if show:
        plt.show()
    mpld3.show()

if __name__ == "__main__":

    if len(sys.argv) < 4:
        print("Usage: ./PlotAmplitudes.py FILENAME AXIS VALUE [PREFIX] [XMIN XMAX YMIN YMAX]")
        exit(0)

    if len(sys.argv) == 5:
        file_prefix=sys.argv[4]
    else:
        file_prefix=""

    if len(sys.argv) == 6:
        save=False
        show=True
    else:
        save=True
        show=False

    if len(sys.argv) == 9:
        xmin = float(sys.argv[5])
        xmax = float(sys.argv[6])
        ymin = float(sys.argv[7])
        ymax = float(sys.argv[8])
    else:
        xmin = None
        xmax = None
        ymin = None
        ymax = None

    plot_slice(sys.argv[1], sys.argv[2], float(sys.argv[3]), save=save, file_prefix=file_prefix, show=show, amp_max=2300, xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)
